给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长**
**子串**的长度。

**示例 1:**
**输入:** s = "abcabcbb"
**输出:** 3 
**解释:** 因为无重复字符的最长子串是 `"abc"`，所以其长度为 3。

**示例 2:**
**输入:** s = "bbbbb"
**输出:** 1
**解释:** 因为无重复字符的最长子串是 `"b"`，所以其长度为 1。

**示例 3:**
**输入:** s = "pwwkew"
**输出:** 3
**解释:** 因为无重复字符的最长子串是 `"wke"`，所以其长度为 3。
     请注意，你的答案必须是 **子串** 的长度，`"pwke"` 是一个_子序列，_不是子串。

**提示：**
- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

```
class Solution { 
	public: int lengthOfLongestSubstring(string s) { 
		vector<int> m(128, 0); 
		int ans = 0; 
		int i = 0; 
		for (int j = 0; j < s.size(); j++) { 
			i = max(i, m[s[j]]); 
			m[s[j]] = j + 1; 
			ans = max(ans, j - i + 1); 
		} 
		return ans; 
	} 
};
```
## 笔记补充：
1. 用vector存储对应字母所在的最大位置
2. 用i指针去定位重复字母，j指针去遍历
3. 在循环中通过i = max(i, m[s[j]])去定位i的位置。当m[s[j]]>i的时候说明s[j]与s[i]对应字母重复，左指针立刻去往m[s[j]]处。
4. 通过m[s[j]] = j + 1去赋值对应字母所在的最大位置
5. 通过ans = max(ans, j - i + 1)去判断无重复字符的最长字串的长度。